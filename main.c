#include "main.h"
#include <stdlib.h>
#include <stdio.h>
#include <stdio.h>
#include <stdlib.h>
#include "jacket.h"
#include "background.h"
#include "gba.h"
#include "goScreen.h"
#include "pipeBody.h"
#include "pipeNeckBottom.h"
#include "pipeNeckTop.h"
#include "start.h"

/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

typedef struct {
    volatile int showing;
    int column;
    int topHeight;
    int gapDistance;
} Pipe;

typedef struct {
    int row;
    int column;
} Jacket;

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
    START,
    START_NO_DRAW,
    PLAY,
    GAME_OVER,
    GAME_OVER_NO_DRAW
};

const int jacketWidth = JACKET_WIDTH;
const int jacketHeight = JACKET_HEIGHT;
const int pipeBodyWidth = PIPEBODY_WIDTH;
const int pipeBodyHeight = PIPEBODY_HEIGHT;
const int pipeNeckWidth = PIPENECKBOTTOM_WIDTH;
const int pipeNeckHeight = PIPENECKBOTTOM_LENGTH;
const int margin = 1;
const int delayTime = 1;
const int grav = 1;
const int flyHeight = 5;
const int pipeSpeed = 1;
const int pipeDist = 100;
const int pipeNum = 5;

void reset(void);

void regenPipes(void);

void enablePipe(Pipe *pipe);

void genPipeHeight(Pipe *pipe);

void drawJacket(void);

void undrawJacket(const u16 *image);

void drawPipe(Pipe *pipe);

void undrawPipeBot(Pipe *pipe, const u16 *image);

void drawPipes(void);

void undrawPipes(void);

void applyGrav(void);

void movePipes(void);

void fly(void);

void flyLess(void);

int collided(Jacket *jacket1, Pipe *pipe);

int isAlive(void);

volatile int score = 0;
Jacket proudJacket;
Pipe *pipes;
Pipe *currPipe;
Pipe *next;

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
    REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Load initial application state
//    enum gba_state state = START;
//
//    int startLastFrame = 0;
//    int upLastFrame = 0;
//    int selectLastFrame = 0;

//    while (1) {
//        waitForVBlank();
//        switch (state) {
//            case START:
//                reset();
//                state = START_NO_DRAW;
//                drawFullScreenImageDMA(startScreen);
//                drawJacket();
//                drawPipes();
//                drawString(50, (240 - calcStringWidth("Press UP button to get started")) / 2, "Press UP button to get started", WHITE);
//                break;
//
//            case START_NO_DRAW:
//                if (KEY_DOWN_NOW(BUTTON_UP) && !upLastFrame) {
//                    drawFullScreenImageDMA(background);
//                    state = PLAY;
//                }
//                break;
//
//            case PLAY:
//                undrawJacket(background);
//                undrawPipes();
//                movePipes();
//                applyGrav();
//                if (KEY_DOWN_NOW(BUTTON_UP)) {
//                    if (upLastFrame) {
//                        proudJacket.row -= flyHeight-2;
//                    } else {
//                        flyLess();
//                    }
//                }
//                if (!isAlive() && !(KEY_DOWN_NOW(BUTTON_A))) {
//                    state = GAME_OVER;
//                    break;
//                }
//                drawJacket();
//                drawPipes();
//                break;
//            case GAME_OVER:
//                drawFullScreenImageDMA(gameoverScreen);
//                char string[5];
//                sprintf(string, "%d", score);
//                drawString(68, 150, string, WHITE);
//                drawString(150, (240 - calcStringWidth("Press ENTER to restart")) / 2, "Press ENTER to restart", WHITE);
//                state = GAME_OVER_NO_DRAW;
//                break;
//            case GAME_OVER_NO_DRAW:
//                if (KEY_DOWN_NOW(BUTTON_START) && !startLastFrame) {
//                    state = START;
//                }
//                break;
//        }
//        if (KEY_DOWN_NOW(BUTTON_START)) {
//            startLastFrame = 1;
//        } else {
//            startLastFrame = 0;
//        }
//        if (KEY_DOWN_NOW(BUTTON_UP)) {
//            upLastFrame = 1;
//        } else {
//            upLastFrame = 0;
//        }
////        if (KEY_DOWN_NOW(BUTTON_SELECT)) {
////            selectLastFrame = 1;
////        } else {
////            selectLastFrame = 0;
////        }
//    }

}

// resets the status of the game
void reset(void) {
    if (pipes != NULL) {
        free(pipes);
    }
    pipes = malloc(sizeof(Pipe) * pipeNum);
    currPipe = pipes;

    regenPipes();

    proudJacket.column = 240 / 6;
    proudJacket.row = 160 / 2 - jacketHeight / 2;
    score = 0;
}

// pipe data generated
void regenPipes(void) {
    enablePipe(pipes);
    for (int i = 1; i < pipeNum; ++i) {
        pipes[i].showing = 0;
        genPipeHeight(pipes + i);
        pipes[i].column = pipes[0].column + i * pipeDist;
    }
}

// making pipes visible
void enablePipe(Pipe *pipe) {
    pipe->showing = 1;
    pipe->column = 240 - pipeNeckWidth-1;
    genPipeHeight(pipe);
}

// check if the jacket collided to a pipe
int collided(Jacket *jacket1, Pipe *pipe) {
    if (jacket1->row > (pipe->topHeight-1) && (jacket1->row + jacketHeight) < pipe->topHeight + pipe->gapDistance) {
        return 0;
    } else {
        if ((jacket1->column + jacketWidth) < pipe->column || jacket1->column > pipe->column + pipeNeckWidth) {
            return 0;
        } else {
            return 1;
        }
    }
}

// check if the jacket survived
int isAlive(void) {
    return !collided(&proudJacket, currPipe) && proudJacket.row < 160;
}

// generate a random pipe
void genPipeHeight(Pipe *pipe) {
    int bHeight = pipeNeckHeight + 10;
    pipe->gapDistance = (jacketHeight*3) + rand() % (jacketHeight*4);
    pipe->topHeight = rand() % (160 - pipe->gapDistance - bHeight) + (bHeight/2);
}

// draw a yellow jacket
void drawJacket(void) {
    drawImageDMA(proudJacket.row, proudJacket.column, jacketWidth, jacketHeight, jacket);
}

// undo drawing a yellow jacket
void undrawJacket(const u16 *image) {
    undrawImageDMA(proudJacket.row, proudJacket.column, jacketWidth, jacketHeight, image);
}

// draw pipes
void drawPipes(void) {
    for (int i = 0; i < pipeNum; ++i) {
        drawPipe(pipes + i);
    }
}

// draws one pipe
void drawPipe(Pipe *pipe) {
    if (!pipe->showing) {
        return;
    }
    if (pipe->column < 0) {
        for (int i = 0; i < pipe->topHeight - pipeNeckHeight; ++i) {
            drawImageDMAFromColumn(i, -1, -pipe->column - margin, pipeBodyWidth+1, pipeBodyHeight, pipeBody);
        }
        drawImageDMAFromColumn(pipe->topHeight-pipeNeckHeight, 0, -pipe->column, pipeNeckWidth, pipeNeckHeight, pipeNeckTop);
        drawImageDMAFromColumn(pipe->topHeight-pipe->gapDistance, 0, -pipe->column, pipeNeckWidth, pipeNeckHeight, pipeNeckBottom);
        for (int i = 0; i < 160 - (pipe->topHeight+pipe->gapDistance+pipeNeckHeight); ++i) {
            drawImageDMAFromColumn(i + pipe->topHeight + pipe->gapDistance + pipeNeckHeight, -1, -pipe->column - margin,
                                   pipeBodyWidth + 1, pipeBodyHeight, pipeBody);
        }
    } else {
        for (int i = 0; i < pipe->topHeight - pipeNeckHeight; ++i) {
            drawImageDMA(i, pipe->column + margin, pipeBodyWidth, pipeBodyHeight, pipeBody);
        }
        drawImageDMA(pipe->topHeight - pipeNeckHeight, pipe->column, pipeNeckWidth, pipeNeckHeight, pipeNeckTop);
        drawImageDMA(pipe->topHeight + pipe->gapDistance, pipe->column, pipeNeckWidth, pipeNeckHeight, pipeNeckBottom);
        for (int i = 0; i < 160 - (pipe->topHeight + pipe->gapDistance + pipeNeckHeight); ++i) {
            drawImageDMA(i + pipe->topHeight + pipe->gapDistance + pipeNeckHeight, pipe->column + margin, pipeBodyWidth,
                       pipeBodyHeight, pipeBody);
        }
    }
}

// undraw pipes
void undrawPipes(void) {
    for (int i = 0; i < pipeNum; ++i) {
        undrawPipeBot(pipes+i, background);
    }
}

// undraw the bottom of a pipes
void undrawPipeBot(Pipe *pipe, const u16 *image) {
    if (!pipe->showing) {
        return;
    }
    for (int i = 0; i < pipe->topHeight - pipeNeckHeight; ++i) {
        undrawImageDMA(i, pipe->column + margin + pipeBodyWidth - 1, pipeSpeed + 1, pipeBodyHeight, image);
    }
    undrawImageDMA(pipe->topHeight - pipeNeckHeight, pipe->column + pipeNeckWidth - 1, pipeSpeed, pipeNeckHeight, image);
    undrawImageDMA(pipe->topHeight + pipe->gapDistance, pipe->column + pipeNeckWidth - 1, pipeSpeed, pipeNeckHeight, image);
    for (int i = 0; i < 160 - (pipe->topHeight + pipe->gapDistance + pipeNeckHeight); ++i) {
        undrawImageDMA(i + pipe->topHeight + pipe->gapDistance + pipeNeckHeight, pipe->column + margin + pipeBodyWidth - 1,
                     pipeSpeed + 1, pipeBodyHeight, image);
    }
}

// gravity
void applyGrav(void) {
    proudJacket.row += grav;
}

// fly
void fly(void) {
    proudJacket.row -= flyHeight;
}

//fly less
void flyLess(void) {
    proudJacket.row -= flyHeight-3;
}

// move pipes for the game to continue
void movePipes(void) {
    if (next != NULL && currPipe->column + pipeNeckWidth < 0) {
        free(pipes);
        pipes = next;
        currPipe = next;
        regenPipes();
        next = NULL;
    }
    for (int i = 0; i < pipeNum; ++i) {
        pipes[i].column -= pipeSpeed;
        if (pipes[i].column < 240 - pipeNeckWidth && pipes[i].column + pipeNeckWidth > 0) {
            pipes[i].showing = 1;
        } else {
            pipes[i].showing = 0;
        }
        if (pipes[i].column <= proudJacket.column + jacketWidth) {
            if (i == pipeNum - 1) {
                pipes = malloc(sizeof(Pipe) * pipeNum);
            } else {
                next = NULL;
            }
            if (currPipe != pipes + i) {
                score++;
            }
            currPipe = pipes + i;
        }
    }
}